<problem chapter='3' section='2' slide='1' problem='8' title='A procedurálistól az objektumorientált megközelítésig'>

<!--
Update history:
2020-09-30 Grzegorz (review, PEP-8 compliance check, update)
-->

<code>class Stack:
    def __init__(self):
        self.__stack_list = []

    def push(self, val):
        self.__stack_list.append(val)

    def pop(self):
        val = self.__stack_list[-1]
        del self.__stack_list[-1]
        return val


stack_object_1 = Stack()
stack_object_2 = Stack()

stack_object_1.push(3)
stack_object_2.push(stack_object_1.pop())

print(stack_object_2.pop())

</code>



<h1>Az objektumos megközelítés: verem létrehozása</h1>

<p>Egy ilyen osztály létrehozása új lehetõségeket nyit meg. Például mostantól több, azonos módon viselkedõ verem is rendelkezésünkre állhat. Minden veremnek saját példánya lesz a privát adatokból, de ugyanazt a metóduskészletet fogja használni.</p>

<p>Ebben a példában pontosan ezt szeretnénk megtenni.</p>

<p>Elemezzük a kódot:</p>

<codep>class Stack:
    def __init__(self):
        self.__stack_list = []

    def push(self, val):
        self.__stack_list.append(val)

    def pop(self):
        val = self.__stack_list[-1]
        del self.__stack_list[-1]
        return val


<mark class="mark-background">stack_object_1 = Stack()</mark>
<mark class="mark-background">stack_object_2 = Stack()</mark>

stack_object_1.push(3)
stack_object_2.push(stack_object_1.pop())

print(stack_object_2.pop())

</codep>
<br>

<p><strong>Ugyanabból a bázis osztályból két vermet hoztunk létre</strong>. Ezek <strong>egymástól függetlenül</strong> mûködnek. Többet is készíthetünk belõlük, ha akarunk.</p>

<p>Futtassuk a kódot a szerkesztõprogramban, és nézzük meg, mi történik. Próbáld ki saját ötleteid!</p>

<br>
<br>

<studyMode>false</studyMode>
<labMode>false</labMode>

</problem>
