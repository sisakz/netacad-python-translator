<problem chapter='4' section='5' slide='1' problem='8' title='Függvények | Rekurzió'>

<!--
Update history:
2020-08-18 Grzegorz (reviewed, re-formatted, PEP-8 compliance check)
-->

<code>

def fib(n):
    if n < 1:
         return None
    if n < 3:
        return 1

    elem_1 = elem_2 = 1
    the_sum = 0
    for i in range(3, n + 1):
        the_sum = elem_1 + elem_2
        elem_1, elem_2 = elem_2, the_sum
    return the_sum


for n in range(1, 10):
    print(n, "->", fib(n))

</code>



<h1>Egyszerű függvények: rekurzió</h1>

<p>Még egy dolgot szeretnénk megmutatni, hogy minden teljes legyen - ez a <strong>rekurzió</strong>.</p>

<p>Ez a kifejezés számos különböző fogalmat írhat le, amik közül számunkra a számítógépes programozásra utaló különösen fontos.</p>

<p>Ezen a területen a rekurzió egy olyan <strong>technika, amelyben egy függvény önmagát hívja meg</strong>.</p>

<p>Az előző két eset tűnik a legjobbnak a jelenség illusztrálására: faktoriálisok és Fibonacci-számok. Különösen az utóbbi.</p>

<p><strong>A Fibonacci-számok definíciója egyértelmű példája a rekurziónak</strong>. Ezt már korábban említettük:</p>


<p><font size="+1"><strong>Fib<sub>i</sub> = Fib<sub>i-1</sub> + Fib<sub>i-2</sub></strong></font></p>


<p>Az i-edik szám definíciója az i-1 számra vonatkozik, és így tovább, amíg el nem érjük az első kettőt.</p>

<p>Használható ez a kódban? Igen, használható. Rövidebbé és érthetőbbé teheti a kódot.</p>


<p>A <codel>fib()</codel> függvényünk második változata közvetlenül ezt a definíciót használja:</p>

<codep class="syntax-color copy">def fib(n):
    if n < 1:
        return None
    if n < 3:
        return 1
    return fib(n - 1) + fib(n - 2)
</codep>

<br>

<p>A kód most már sokkal világosabb.</p>

<p>De vajon tényleg biztonságos? Jelent bármennyi kockázatot?</p>

<p>Igen, valóban van egy kis kockázat. <strong>Ha elfelejtjük figyelembe venni azokat a feltételeket, amelyek megállíthatják a rekurzív meghívások láncolatát, a program végtelen ciklusba kerülhet</strong>. Óvatosnak kell lennünk!</p>


<p>A faktoriálisnak is van egy második, <strong>rekurzív</strong> oldala is. Nézd!</p>

<p style="font-family:courier new;">n! = 1 &times; 2 &times; 3 &times; ... &times; n-1 &times; n</p>
<br>

<p>Nyilvánvalóan:</p>

<p style="font-family:courier new;">1 &times; 2 &times; 3 &times; ... &times; n-1 = (n-1)!</p>

<br>

<p>Így végül az eredmény:</p>

<p style="font-family:courier new;">n! = (n-1)! &times; n</p
<br>

<p>Ez tulajdonképpen egy kész recept az új megoldásunkhoz.</p>

<br>

<p>Itt is van:</p>

<codep class="syntax-color copy">def factorial_function(n):
    if n < 0:
        return None
    if n < 2:
        return 1
    return n * factorial_function(n - 1)
</codep>

<br>

<p>Működik? Igen, működik. Próbáld ki!</p>

<p>Rövid <i>függvénytani</i> utazásunk majdnem véget ért. A következő részben két furcsa Python adattípussal foglalkozunk: a tuplikkal és a szótárakkal.</p>


<br>

<studyMode>false</studyMode>
<labMode>false</labMode>

</problem>
