<problem chapter='3' section='3' slide='1' problem='2' title='Logikai és bitszintű műveletek | and, or, not'>

<!--
Update history:
2020-07-21 Grzegorz (reviewed, reformatted)
-->

<div class="container">
<div class="row">

<div class="small-12 large-4 columns">


<h1>Logikai kifejezések</h1>

<p>Hozzunk létre egy <codel>var</codel> nevű változót, és rendeljük hozzá az <codel>1</codel> értéket. A következő feltételek <strong>páronként egyenértékűek</strong>:</p>

<codep># Example 1:
print(<mark style="background-color:#e6f2ff;">var > 0</mark>)
print(<mark style="background-color:#e6f2ff;">not (var <= 0)</mark>)


# Example 2:
print(<mark style="background-color:#e6f2ff;">var != 0</mark>)
print(<mark style="background-color:#e6f2ff;">not (var == 0)</mark>)

</codep>

<br>

<hr>

<p>Talán ismered De Morgan törvényeit, amelyek ezt mondják:</p>

<p><i>Egy konjunkció tagadása a tagadások diszjunkciója.</i></p>

<p><i>A diszjunkció tagadása a tagadások konjunkciója.</i></p>

<br>

<p>Írjuk meg ugyanezt Python nyelven:</p>

<codep class="syntax-color">not (p and q) == (not p) or (not q)
not (p or q) == (not p) and (not q)
</codep>

<br>


<p>Figyeld meg, hogyan használtuk a zárójeleket a kifejezések kódolásához! Az olvashatóság érdekében tettük őket oda.</p>

<p>Hozzá kell tennünk, hogy a fenti kétargumentumos operátorok egyike sem használható az <codel>op=</codel>rövidített formában. Ezt a kivételt érdemes megjegyezni.</p>


<h2>Logikai értékek vs. egyes bitek</h2>


<p>A logikai operátorok az argumentumaikat egyben tekintik, függetlenül attól, hogy hány bitet tartalmaznak. Az operátorok csak két értéket ismernek: a nulla (amikor az összes bit vissza van állítva) azt jelenti, hogy <codel>False</codel>; a nem nulla (amikor legalább egy bit be van állítva) azt jelenti, hogy <codel>True</codel>.</p>

<p>Műveleteik eredménye ezen értékek egyike: <codel>False</codel> vagy <codel>True</codel>. Ez azt jelenti, hogy ez a kódrészlet a <codel>j</codel> változóhoz a <codel>True</codel> értéket rendeli, ha <codel>i</codel> nem nulla, ellenkező esetben pedig a <codel>False</codel> értéket.</p>

<codep class="syntax-color">i = 1
j = not not i
</codep>

<br>





</div>





<div class="small-12 large-8 columns">

<h1>Bitwise operátorok</h1>

<p>Van azonban négy olyan operátor, amely lehetővé teszi az <strong>egyes adatbitek manipulálását</strong>. Ezeket <strong>bitwise (bitszintű) operátoroknak</strong> nevezzük.</p>

<p>Ezek lefedik az összes korábban említett logikai műveletet, valamint egy további operátort. Ez az <codel>xor</codel> (mint <strong>exclusive or (kizárólagos vagy)</strong>) operátor, és <codel>^</codel>-vel (caret) jelöljük.</p>

<p>Itt van az összes:</p>

<ul>
<li><codel>&amp;</codel> (ampersand) ‒ bitwise konjunkció;</li>
<li><codel>|</codel> (bar) ‒ bitwise diszjunkció;</li>
<li><codel>~</codel> (tilde) ‒ bitwise tagadás;</li>
<li><codel>^</codel> (caret) ‒ bitwise kizáról vagy (xor).</li>
</ul>

<br>



<table style="width:98%" align="middle">
<caption>Bitszintű műveletek (<codel>&amp;</codel>, <codel>|</codel>, és <codel>^</codel>)</caption>

<tr>
<th><codel>A</codel> argumentum</th>
<th><codel>B</codel> argumentum</th>
<th><codel>A &amp; B</codel></th>
<th><codel> A | B</codel></th>
<th><codel>A ^ B</codel></th>
</tr>

<tr>
<td><codel>0</codel></td>
<td><codel>0</codel></td>
<td><codel>0</codel></td>
<td><codel>0</codel></td>
<td><codel>0</codel></td>
</tr>

<tr>
<td><codel>0</codel></td>
<td><codel>1</codel></td>
<td><codel>0</codel></td>
<td><codel>1</codel></td>
<td><codel>1</codel></td>
</tr>

<tr>
<td><codel>1</codel></td>
<td><codel>0</codel></td>
<td><codel>0</codel></td>
<td><codel>1</codel></td>
<td><codel>1</codel></td>
</tr>

<tr>
<td><codel>1</codel></td>
<td><codel>1</codel></td>
<td><codel>1</codel></td>
<td><codel>1</codel></td>
<td><codel>0</codel></td>
</tr>

</table>


<br>

<table style="width:45%" align="middle">
<caption>Bitszintű műveletek (~)</caption>

<tr>
<th>Argumentum</th>
<th><codel>~</codel> argumenum</th>

</tr>

<tr>
<td><codel>0</codel></td>
<td><codel>1</codel></td>

</tr>

<tr>
<td><codel>1</codel></td>
<td><codel>0</codel></td>

</tr>
</table>

<br>

<p>Nézzük meg jobban:</p>

<ul>
<li><codel>&</codel> pontosan két <codel>1</codel>-est igényel ahhoz, hogy az eredmény <codel>1</codel> legyen;</li>
<li><codel>|</codel> legalább egy <codel>1</codel>-est igényel ahhoz, hogy az eredmény <codel>1</codel> legyen;</li>
<li><codel>^</codel> pontosan egy <codel>1</codel>-est igényel ahhoz, hogy az eredmény <codel>1</codel> legyen.</li>
</ul>

<br>

<hr>

<p>Tegyünk hozzá egy fontos megjegyzést: ezen operátorok argumentumainak <strong>egész számoknak kell lenniük</strong>, itt nem használhatunk lebegőpontos számokat.</p>

<p>A logikai és a bitwise operátorok működése közötti fontos különbség: <strong>a logikai operátorok nem hatolnak be az argumentum bitszintjére</strong>. Ezeket csak a végső egész érték érdekli.</p>

<p>A bitwise operátorok szigorúbbak: <strong>minden bitet külön</strong> kezelnek. Ha feltételezzük, hogy az egész szám változó 64 bitet foglal el (ami a modern számítógépes rendszerekben gyakori), akkor a bitszintű műveletet úgy képzelhetjük el, mint a logikai operátor 64-szeres kiértékelését az argumentumok minden egyes bitpárjára. Ez az analógia nyilvánvalóan nem tökéletes, mivel a való világban mind a 64 művelet egyszerre (egyidejűleg) történik.</p>



<br>


</div>


</div>
</div>


<studyMode>true</studyMode>
<labMode>false</labMode>

</problem>
