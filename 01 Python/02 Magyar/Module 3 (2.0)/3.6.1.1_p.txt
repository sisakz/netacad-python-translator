<problem chapter='3' section='6' slide='1' problem='1' title='Műveletek listákkal'>

<!--
Update history:
2020-08-12 Grzegorz (reviewed, reformatted)
-->

<code>
list_1 = [1]
list_2 = list_1
list_1[0] = 2
print(list_2)

</code>



<h1>A listák belső élete</h1>

<p>Most a listák egy fontos és nagyon meglepő tulajdonságát fogjuk bemutatni, amely erősen megkülönbözteti őket a közönséges változóktól.</p>

<p>Szeretnénk, ha ezt megjegyeznéd! Hatással lehet a jövőbeli programjaidra, és komoly problémákat okozhat, ha elfelejted vagy figyelmen kívül hagyod.</p>

<p>Nézd meg a szerkesztőben lévő kódrészletet!</p>

<p>A program:</p>

<ul>

<li>létrehoz egy egyelemű listát <codel>list_1</codel> néven;</li>
<li>hozzárendeli egy új listához, amelynek neve <codel>list_2</codel>;</li>
<li>megváltoztatja a <codel>list_1</codel> egyetlen elemét;</li>
<li>megjeleníti a <codel>list_2</codel>-t.</li>

</ul>

<p>A meglepő az, hogy a program kimenete a következő lesz: <codel>[2]</codel>, nem pedig <codel>[1]</codel>, ami a kézenfekvő megoldásnak tűnne.</p>

<br>

<p>A listák (és sok más összetett Python-entitás) tárolása más módon történik, mint a közönséges (skalár) változóké.</p>

<p>Úgy is mondhatnánk:</p>

<ul>
<li>egy közönséges változó neve a <strong>tartalmának a neve</strong>;</li>
<li>egy lista neve annak a <strong>memóriahelynek a neve, ahol a lista tárolódik</strong>.</li>
</ul>

<p>Olvasd el még egyszer ezt a két sort. A különbség lényeges ahhoz, hogy megértsd, miről fogunk beszélni a következőkben.</p>

<p>A <codel>list_2 = list_1</codel> értékadás a tömb nevét másolja, nem pedig a tartalmát! A két név (<codel>list_1</codel> és <codel>list_2</codel>) valójában ugyanazt a helyet jelöli a számítógép memóriájában. Ha az egyiket módosítjuk, az hatással van a másikra is, és fordítva.</p>

<p>Hogyan birkózol meg ezzel?</p>



<br>


<studyMode>false</studyMode>
<labMode>false</labMode>

</problem>
